---
title: "Practice Dec 12, 2016"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache= TRUE, autodep = TRUE)
library(rethinking)
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
```

## Problem 1

Remember the tomato data set generated by Pepe; we first looked at this when we were working on Chapter 9.  35 accessions for seven species were grown in sun and shade.  

Assess whether there is evidence for total length ("totleng") response to shade and whether this response varies by species.  Consider whether including accession ("acs") or shelf ("shelf") using adaptive priors improves the model fit.

### get the data and format
```{r}
tomato <- read.csv("Assignment_Chapter_09/TomatoR2CSHL.csv")
names(tomato)
tomato$species_id <- coerce_index(tomato$species)
tomato$shade <- ifelse(tomato$trt=="L",1,0)
tomato$shelf_id <- coerce_index(tomato$shelf)
tomato$species_id <- coerce_index(tomato$species)
tomato$acs_id <- coerce_index(tomato$acs)
tomato.small <- tomato[,c("shelf_id","acs_id","shade","totleng","species_id")]
summary(tomato.small)
```

### shade effect

```{r}
mean(tomato.small$totleng[tomato.small$shade==0])
m.shade <- map2stan(
  alist(
    totleng ~ dnorm(mu,sigma),
    mu <- alpha + 
      beta_shade*shade,
    alpha ~ dnorm(42,10),
    beta_shade ~ dnorm(0,20),
    sigma ~ dcauchy(0,1)
  ),
  data = tomato.small,
  chains=4
)
```

```{r}
plot(m.shade)
pairs(m.shade)
precis(m.shade)
```

### shade and species

```{r}
m.shade.species <- map2stan(
  alist(
    totleng ~ dnorm(mu,sigma),
    mu <- alpha + 
      beta_sp[species_id] + 
      beta_shade*shade,
    alpha ~ dnorm(42,10),
    beta_sp[species_id] ~ dnorm(0,10),
    beta_shade ~ dnorm(0,20),
    sigma ~ dcauchy(0,1)
  ),
  data = tomato.small,
  chains=4
)
```

```{r}
plot(m.shade.species)
pairs(m.shade.species)
precis(m.shade.species,depth = 2)
compare(m.shade,m.shade.species) 
levels(tomato$species)
```

Good evidence for species being important

### consider species X shade interaction

```{r}
m.shade.species.int <- map2stan(
  alist(
    totleng ~ dnorm(mu,sigma),
    mu <- alpha + 
      beta_sp[species_id] + 
      beta_shade*shade + 
      beta_sp_shade[species_id]*shade,
    alpha ~ dnorm(53,20),
    beta_sp[species_id] ~ dnorm(0,10),
    beta_shade ~ dnorm(0,20),
    beta_sp_shade[species_id] ~ dnorm(0,10),
    sigma ~ dcauchy(0,1)
  ),
  data = tomato.small,
  chains=4,
  cores=2
)
```

```{r}
plot(m.shade.species.int)
par(mfrow=c(1,1))
precis(m.shade.species.int,depth=2)
levels(tomato$species)
compare(m.shade,m.shade.species,m.shade.species.int)
plot(coeftab(m.shade,m.shade.species,m.shade.species.int))
```

Reasonable evidence for the interaction, although the 95% posterior intervals overlap among all of the species_shade interactions

### Add adaptive prior for accessions

```{r}
m.shade.species.int.acs <- map2stan(
  alist(
    totleng ~ dnorm(mu,sigma),
    mu <- alpha + 
      alpha_acs[acs_id] +
      beta_sp[species_id] + 
      beta_shade*shade + 
      beta_sp_shade[species_id]*shade,
    alpha ~ dnorm(53,20),
    alpha_acs[acs_id] ~ dnorm(0,sigma_acs),
    beta_sp[species_id] ~ dnorm(0,10),
    beta_shade ~ dnorm(0,20),
    beta_sp_shade[species_id] ~ dnorm(0,10),
    c(sigma,sigma_acs) ~ dcauchy(0,1)
  ),
  data = tomato.small,
  iter = 4000, # Rhat a bit high with defaults
  warmup = 1000,
  chains=4,
  cores=2
)
```


```{r}
plot(m.shade.species.int.acs,ask=FALSE)
par(mfrow=c(1,1))
precis(m.shade.species.int.acs,depth = 2)
compare(m.shade.species.int,m.shade.species.int.acs)
coeftab(m.shade.species.int,m.shade.species.int.acs)
plot(coeftab(m.shade.species.int,m.shade.species.int.acs),pars=1:13)
```

Adding acs does not change most of the shared coefficients by much, although it drops sigma.

## Add shelf random effect

```{r}
table(tomato.small$shade, tomato.small$shelf_id)
table(tomato.small$acs_id,tomato.small$shelf_id)
```

most accessions are on most shelves

```{r}
m.shade.species.int.acs.shelf <- map2stan(
  alist(
    totleng ~ dnorm(mu,sigma),
    mu <- alpha + 
      alpha_acs[acs_id] +
      alpha_shelf[shelf_id]  +
      beta_sp[species_id] + 
      beta_shade*shade + 
      beta_sp_shade[species_id]*shade,
    alpha ~ dnorm(53,20),
    alpha_acs[acs_id] ~ dnorm(0,sigma_acs),
    alpha_shelf[shelf_id] ~ dnorm(0,sigma_shelf),
    beta_sp[species_id] ~ dnorm(0,10),
    beta_shade ~ dnorm(0,20),
    beta_sp_shade[species_id] ~ dnorm(0,10),
    c(sigma,sigma_acs) ~ dcauchy(0,1),
    sigma_shelf ~ dexp(1) # with only 3 shelves per trt might be hard to estimate w. cauchy
  ),
  data = tomato.small,
  iter = 4000, # Rhat a bit high with defaults
  warmup = 1000,
  chains=4,
  cores=2
)
```

```{r}
save.image(file="tomato1212.Rdata")
```


```{r}
plot(m.shade.species.int.acs.shelf,ask=FALSE)
par(mfrow=c(1,1))
precis(m.shade.species.int.acs.shelf,depth = 2)
compare(m.shade,m.shade.species,m.shade.species.int,m.shade.species.int.acs,m.shade.species.int.acs.shelf)
coeftab(m.shade.species.int.acs,m.shade.species.int.acs.shelf)
plot(coeftab(m.shade.species.int.acs,m.shade.species.int.acs.shelf),pars=c(1,38:50))
```

including shelf does not change the estimates much, although that model is apparently preferred

### reparamterize with no "main" shade effect


```{r}
m.shade.species.sep.acs.shelf <- map2stan(
  alist(
    totleng ~ dnorm(mu,sigma),
    mu <- alpha + 
      alpha_acs[acs_id] +
      alpha_shelf[shelf_id]  +
      beta_sp[species_id] + 
      beta_sp_shade[species_id]*shade,
    alpha ~ dnorm(53,20),
    alpha_acs[acs_id] ~ dnorm(0,sigma_acs),
    alpha_shelf[shelf_id] ~ dnorm(0,sigma_shelf),
    beta_sp[species_id] ~ dnorm(0,10),
    beta_sp_shade[species_id] ~ dnorm(0,20),
    c(sigma,sigma_acs) ~ dcauchy(0,1),
    sigma_shelf ~ dexp(1) # with only 3 shelves per trt might be hard to estimate w. cauchy
  ),
  data = tomato.small,
  iter = 4000, # Rhat a bit high with defaults
  warmup = 1000,
  chains=4,
  cores=4
)
```

```{r}
save.image(file="tomato1212.Rdata")
```

```{r}
plot(m.shade.species.sep.acs.shelf,ask=FALSE)
par(mfrow=c(1,1))
precis(m.shade.species.sep.acs.shelf,depth = 2)
compare(m.shade,m.shade.species,m.shade.species.int,m.shade.species.int.acs,m.shade.species.int.acs.shelf,m.shade.species.sep.acs.shelf)
coeftab(m.shade.species.sep.acs.shelf,m.shade.species.int.acs.shelf)
plot(coeftab(m.shade.species.sep.acs.shelf))
```

This parameterization leads to the same WAIC, so it is an equivalent model.  Interestingly though, the SD on the shade coefficients is smaller, presumably because one fewer parameter is being estimated.

Can we do no main alpha?
```{r}
m.shade.species.sep.acs.shelf.no.alpha <- map2stan(
  alist(
    totleng ~ dnorm(mu,sigma),
    mu <- 
      alpha_acs[acs_id] +
      alpha_shelf[shelf_id]  +
      beta_sp[species_id] + 
      beta_sp_shade[species_id]*shade,
    alpha_acs[acs_id] ~ dnorm(0,sigma_acs),
    alpha_shelf[shelf_id] ~ dnorm(0,sigma_shelf),
    beta_sp[species_id] ~ dnorm(42,20),
    beta_sp_shade[species_id] ~ dnorm(0,20),
    c(sigma,sigma_acs) ~ dcauchy(0,1),
    sigma_shelf ~ dexp(1) # with only 3 shelves per trt might be hard to estimate w. cauchy
  ),
  data = tomato.small,
  iter = 4000, # Rhat a bit high with defaults
  warmup = 1000,
  chains=4,
  cores=4
)
```

```{r}
save.image(file="tomato1212.Rdata")
```

```{r}
plot(m.shade.species.sep.acs.shelf.no.alpha,ask=FALSE)
par(mfrow=c(1,1))
precis(m.shade.species.sep.acs.shelf.no.alpha,depth = 2)
compare(m.shade,m.shade.species,m.shade.species.int,m.shade.species.int.acs,m.shade.species.int.acs.shelf,m.shade.species.sep.acs.shelf,m.shade.species.sep.acs.shelf.no.alpha)
coeftab(m.shade.species.sep.acs.shelf,m.shade.species.int.acs.shelf)
plot(coeftab(m.shade.species.sep.acs.shelf.no.alpha))
```

So long as an appropriate prior for the species intercepts is used this is OK.  The other reasonable paramaterization would be to have the alpha befor the first species.

### Consider different slopes for accessions

```{r}
m.shade.species.sep.acs.int.shelf.no.alpha <- map2stan(
  alist(
    totleng ~ dnorm(mu,sigma),
    mu <- alpha_acs[acs_id] +
      alpha_shelf[shelf_id]  +
      beta_sp[species_id] + 
      beta_acs_shade[acs_id]*shade,
    alpha_acs[acs_id] ~ dnorm(0,sigma_acs),
    alpha_shelf[shelf_id] ~ dnorm(0,sigma_shelf),
    beta_sp[species_id] ~ dnorm(42,10),
    beta_acs_shade[acs_id] ~ dnorm(20,20),
    c(sigma,sigma_acs,sigma_shelf) ~ dcauchy(0,1)
  ),
  data = tomato.small,
  iter = 4000, # Rhat a bit high with defaults
  warmup = 1000,
  chains=4,
  cores=4
)
```

```{r}
save.image("tomato1212.Rdata")
```


```{r}
plot(m.shade.species.sep.acs.int.shelf.no.alpha,ask=FALSE)
par(mfrow=c(1,1))
precis(m.shade.species.sep.acs.int.shelf.no.alpha,depth = 2)
compare(m.shade.species.sep.acs.int.shelf.no.alpha,m.shade.species.sep.acs.shelf.no.alpha)
coeftab(m.shade.species.sep.acs.int.shelf.no.alpha,m.shade.species.sep.acs.shelf.no.alpha)
plot(coeftab(m.shade.species.sep.acs.int.shelf.no.alpha,m.shade.species.sep.acs.shelf.no.alpha),pars=c(1,44:56))
```

### drop the species shade interaction


```{r}
m.shade.species.acs.int.shelf <- map2stan(
  alist(
    totleng ~ dnorm(mu,sigma),
    mu <- alpha + 
      alpha_acs[acs_id] +
      alpha_shelf[shelf_id]  +
      beta_sp[species_id] + 
      beta_shade*shade + 
      beta_acs_shade[acs_id]*shade,
    alpha ~ dnorm(53,20),
    alpha_acs[acs_id] ~ dnorm(0,sigma_acs),
    alpha_shelf[shelf_id] ~ dnorm(0,sigma_shelf),
    beta_sp[species_id] ~ dnorm(0,10),
    beta_shade ~ dnorm(0,20),
    beta_acs_shade[acs_id] ~ dnorm(0,10),
    c(sigma,sigma_acs,sigma_shelf) ~ dcauchy(0,1)
  ),
  data = tomato.small,
  iter = 4000, # Rhat a bit high with defaults
  warmup = 1000,
  chains=4,
  cores=4
)
```

```{r}
save.image("tomato1212.Rdata")
```


```{r}
plot(m.shade.species.acs.int.shelf,ask=FALSE)
par(mfrow=c(1,1))
precis(m.shade.species.acs.int.shelf,depth = 2)
compare(m.shade.species.int.acs.shelf,m.shade.species.acs.int.shelf)
coeftab(m.shade.species.acs.int.shelf)
plot(coeftab(m.shade.species.acs.int.shelf),pars=c(1:42))
plot(coeftab(m.shade.species.acs.int.shelf),pars=c(43:86))
```

We don't need both a species response and an accession response (interaction) term.  If we are only keeping one of the terms then the accession interaction model is preferred.

From this I conclude that variation is better considered at the accession level than at the species level.


## Smoking deaths among doctors

In 1961 Doll and Hill sent out a questionnaire to all men on the British Medical Register inquiring about their smoking habits. Almost 70% of such men replied. Death certificates were obtained for medical practitioners and causes of death were assigned on the basis of these certificates. The breslow data set contains the person-years of observations and deaths from coronary artery disease accumulated during the first ten years of the study.

Analyse this data set to determine the posterior probability that smoking increases death by coronary artery disease, that age increases death by coronary artery disease, and that there is an interaction between age and smoking.

You can load the data set and learn about the columns using the commands below

```{r}
data("breslow",package = "boot")
help("breslow",package ="boot")
breslow
```

You can think of "person-years" as the number of observations

```{r}
breslow$n <- as.integer(breslow$n)
m.smoke <- map2stan(alist(
  y~dbinom(n,p),
  logit(p) <- alpha + beta_smoke * smoke,
  alpha ~ dnorm(0,5),
  beta_smoke ~ dnorm(0,5)),
  data=breslow,
  chains = 4,
  cores = 2)
save.image("tomato1212.Rdata")
```

```{r}
plot(m.smoke)
pairs(m.smoke)
precis(m.smoke)
logistic(-5.97)
logistic(-5.97 + 0.55)
```

```{r}
breslow$age_id <- coerce_index(breslow$age)
m.age <- map2stan(alist(
  y~dbinom(n,p),
  logit(p) <- alpha_age[age_id],
  alpha_age[age_id] ~ dnorm(0,5)),
  data=breslow,
  chains = 4,
  cores = 2)
save.image("tomato1212.Rdata")
```

```{r}
plot(m.age)
precis(m.age,depth=2)
logistic(precis(m.age,depth=2)@output$Mean)
pairs(m.age)
compare(m.age,m.smoke)
```

```{r}
m.smoke.age <- map2stan(
  alist(y~dbinom(n,p),
        logit(p) <- alpha_age[age_id] + beta_smoke*smoke,
        alpha_age[age_id] ~ dnorm(0,5),
        beta_smoke ~ dnorm(0,5)),
  data=breslow,
  chains = 4,
  cores = 2)
save.image("tomato1212.Rdata")
```

```{r}
plot(m.smoke.age)
pairs(m.smoke.age)
precis(m.smoke.age,depth=2)
compare(m.age,m.smoke,m.smoke.age)
```

```{r}
m.smoke.age.int <- map2stan(
  alist(y~dbinom(n,p),
        logit(p) <- alpha_age[age_id] + 
          beta_smoke*smoke + 
          beta_smoke_age[age_id]*smoke,
        alpha_age[age_id] ~ dnorm(0,5),
        beta_smoke ~ dnorm(0,5),
        beta_smoke_age[age_id] ~ dnorm(0,5)),
  data=breslow,
  chains = 4,
  cores = 2)
save.image("tomato1212.Rdata")
```

```{r}
plot(m.smoke.age.int)
precis(m.smoke.age.int,depth=2)
compare(m.smoke,m.age,m.smoke.age,m.smoke.age.int)
```

```{r}
pred <- ensemble(m.smoke.age,m.smoke.age.int)
mu <- apply(pred$link,2,mean)
PI <- apply(pred$link,2,PI)
plot.frame <- data.frame(age=breslow$age,smoke=as.factor(breslow$smoke),mean=mu,low=PI[1,],high=PI[2,])
plot.frame
pl <- ggplot(plot.frame,aes(x=age,y=mean,ymax=high,ymin=low,fill=smoke))
pl <- pl + geom_bar(position = "dodge",stat = "identity")
pl + geom_errorbar(position = position_dodge(width=0.9),width=0.5)
```

```{r}
breslow$age_num <- as.numeric(as.character(breslow$age))
m.smoke.age.int.numeric <- map2stan(
  alist(y~dbinom(n,p),
        logit(p) <- alpha +
          beta_age * age_num +
          beta_smoke*smoke + 
          beta_smoke_age*smoke*age_num,
        alpha ~ dnorm(0,10),
        c(beta_smoke,beta_age) ~ dnorm(0,5),
        beta_smoke_age ~ dnorm(0,1)),
  data=breslow,
  chains = 4,
  cores = 2)
save.image("tomato1212.Rdata")
```

```{r}
plot(m.smoke.age.int.numeric)
precis(m.smoke.age.int.numeric)
compare(m.smoke.age.int, m.smoke.age.int.numeric)
```

```{r}

```


## Cane Sugar

This data comes from an experiment to measure disease resistance in different varieties of sugar cane.

You can get the data and learn about it with:

```{r}
data("cane",package="boot")
help("cane",package="boot")
head(cane)
summary(cane)
```


Is there evidence of differences in disease resistance in the different varieties?  Does including an adaptive prior for Block improve the model fit?

```{r}
mean(cane$r/cane$n)
logit(mean(cane$r/cane$n))
cane$var_id <- coerce_index(cane$var)
cane$block_id <- coerce_index(cane$block)
cane$n <- as.integer(cane$n)
m.cane.alpha <- map2stan(
  alist(
    r ~ dbinom(n,p),
    logit(p) <- alpha,
    alpha <- dnorm(-1.55,1)
  ),
  data=cane,
  chains = 4,
  cores = 2
)
```
```{r}
plot(m.cane.alpha)
precis(m.cane.alpha)
logistic(-1.58)
```


```{r}
m.var <- map2stan(
  alist(
    r ~ dbinom(n,p),
    logit(p) <- alpha + alpha_var[var_id],
    alpha <- dnorm(-1.55,1),
    alpha_var[var_id] ~ dnorm(0,5)
  ),
  data=cane,
  chains = 4,
  cores = 2,
  iter=10000,
  warmup = 1000
)
save.image("tomato1212.Rdata")
```

```{r}
plot(m.var,ask=FALSE)
precis(m.var,depth=2)
compare(m.cane.alpha,m.var)
```

```{r}
m.var.block <- map2stan(
    alist(
      r ~ dbinom(n,p),
      logit(p) <- alpha + alpha_var[var_id] + alpha_block[block_id],
      alpha <- dnorm(-1.55,1),
      alpha_var[var_id] ~ dnorm(0,5),
      alpha_block[block_id] ~ dnorm(0,sigma_block),
      sigma_block ~ dcauchy(0,1)
    ),
    data=cane,
    chains = 4,
    cores = 2,
    iter=10000,
    warmup=4000
  )
save.image("tomato1212.Rdata")
```

